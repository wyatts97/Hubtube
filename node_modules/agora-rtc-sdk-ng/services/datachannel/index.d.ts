import { RetryConfiguration, TurnServerConfigWithMode, CloudProxyServerMode, EventEmitter, PromiseMutex, SDKStore, SDK_CODEC, SDK_AUDIO_CODEC, AgoraPCStats, UID, Candidate, Setup, CandidateStats, PayloadAttribute, Extmap, FingerPrint, ConnectionDisconnectedReason, WebSocketQuitReason } from '@agora-js/shared';
import { AgoraRTCPlayer, LocalTrack, LocalDataChannel, RemoteDataChannel, LocalVideoTrackStats, AgoraRTCStats, LocalVideoTrack } from '@agora-js/media';

interface SignalSpec {
    clientId: string;
    retryConfig: RetryConfiguration;
    forceWaitGatewayResponse: boolean;
}
declare enum SignalConnectionState {
    CONNECTING = "connecting",
    CONNECTED = "connected",
    RECONNECTING = "reconnecting",
    CLOSED = "closed"
}
declare enum SignalRequestType {
    PING = "ping",
    PING_BACK = "ping_back",
    JOIN = "join_v3",
    REJOIN = "rejoin_v3",
    LEAVE = "leave",
    SET_CLIENT_ROLE = "set_client_role",
    PUBLISH = "publish",
    PUBLISH_DATASTREAM = "publish_datastream",
    UNPUBLISH = "unpublish",
    UNPUBLISH_DATASTREAM = "unpublish_datastream",
    SUBSCRIBE = "subscribe",
    PRE_SUBSCRIBE = "pre_subscribe",
    SUBSCRIBE_DATASTREAM = "subscribe_datastream",
    SUBSCRIBE_STREAMS = "subscribe_streams",
    UNSUBSCRIBE = "unsubscribe",
    UNSUBSCRIBE_DATASTREAM = "unsubscribe_datastream",
    UNSUBSCRIBE_STREAMS = "unsubscribe_streams",
    SUBSCRIBE_CHANGE = "subscribe_change",
    TRAFFIC_STATS = "traffic_stats",
    RENEW_TOKEN = "renew_token",
    SET_DUAL_STREAM_MODE = "set_dual_stream_mode",
    SWITCH_VIDEO_STREAM = "switch_video_stream",
    DEFAULT_VIDEO_STREAM = "default_video_stream",
    SET_FALLBACK_OPTION = "set_fallback_option",
    CONFIGURE = "configure",
    GATEWAY_INFO = "gateway_info",
    CONTROL = "control",
    SEND_METADATA = "send_metadata",
    DATA_STREAM = "data_stream",
    PICK_SVC_LAYER = "pick_svc_layer",
    RESTART_ICE = "restart_ice",
    CONNECT_PC = "connect_pc",
    SET_VIDEO_PROFILE = "set_video_profile",
    SET_PARAMETER = "set_parameter",
    SET_RTM2_FLAG = "set_rtm2_flag",
    DOWNGRADE_CODEC = "downgrade_codec"
}
declare enum SignalUploadType {
    WRTC_STATS = "wrtc_stats",
    WS_INFLATE_DATA_LENGTH = "ws_inflate_data_length",
    DENOISER_STATS = "denoiser_stats",
    EXTENSION_USAGE_STATS = "extension_usage_stats"
}
declare enum SignalNotifyType {
    ON_USER_ONLINE = "on_user_online",
    ON_USER_OFFLINE = "on_user_offline",
    ON_STREAM_FALLBACK_UPDATE = "on_stream_fallback_update",
    ON_PUBLISH_STREAM = "on_publish_stream",
    ON_UPLINK_STATS = "on_uplink_stats",
    ON_P2P_LOST = "on_p2p_lost",
    ON_REMOVE_STREAM = "on_remove_stream",
    ON_ADD_AUDIO_STREAM = "on_add_audio_stream",
    ON_ADD_VIDEO_STREAM = "on_add_video_stream",
    ON_TOKEN_PRIVILEGE_WILL_EXPIRE = "on_token_privilege_will_expire",
    ON_TOKEN_PRIVILEGE_DID_EXPIRE = "on_token_privilege_did_expire",
    ON_USER_BANNED = "on_user_banned",
    ON_USER_LICENSE_BANNED = "on_user_license_banned",
    ON_NOTIFICATION = "on_notification",
    ON_CRYPT_ERROR = "on_crypt_error",
    MUTE_AUDIO = "mute_audio",
    MUTE_VIDEO = "mute_video",
    UNMUTE_AUDIO = "unmute_audio",
    UNMUTE_VIDEO = "unmute_video",
    ON_P2P_OK = "on_p2p_ok",
    RECEIVE_METADATA = "receive_metadata",
    ON_DATA_STREAM = "on_data_stream",
    ON_RTP_CAPABILITY_CHANGE = "on_rtp_capability_change",
    ON_REMOTE_DATASTREAM_UPDATE = "on_remote_datastream_update",
    ON_REMOTE_FULL_DATASTREAM_INFO = "on_remote_full_datastream_info",
    ENABLE_LOCAL_VIDEO = "enable_local_video",
    DISABLE_LOCAL_VIDEO = "disable_local_video",
    ENABLE_LOCAL_AUDIO = "enable_local_audio",
    DISABLE_LOCAL_AUDIO = "disable_local_audio",
    ON_PUBLISHED_USER_LIST = "on_published_user_list",
    ENABLE_MULTI_STREAM = "enable_multi_stream"
}

interface PeerConnectionSpec {
    iceServers?: RTCIceServer[];
    turnServer?: TurnServerConfigWithMode;
    enableEncodedTransform?: boolean;
    isPreallocation?: boolean;
    cloudProxyServer?: CloudProxyServerMode;
}

interface AnyObject {
    [k: string]: any;
    [j: number]: any;
}

interface ServerAddress {
    ip: string;
    port: number;
    fingerprint?: string;
    domain_prefix?: string;
    ticket: string;
}

interface RemoteConfig {
    tcc?: boolean;
    remb?: boolean;
    twcc?: boolean;
}

type Transmission = WebSocket | RTCDataChannel;
declare abstract class AgoraTransmissionMediumManager<T extends Transmission> extends EventEmitter {
    get url(): string | null;
    connectionID: number;
    currentURLIndex: number;
    reconnectReason?: TransmitterQuitReason;
    get reconnectMode(): "retry" | "tryNext" | "recover";
    set reconnectMode(newMode: "retry" | "tryNext" | "recover");
    get state(): TransmitterConnectionState;
    set state(newState: TransmitterConnectionState);
    protected _reconnectMode: "retry" | "tryNext" | "recover";
    protected abstract _initMutex: PromiseMutex;
    protected readonly _name: string;
    protected _state: TransmitterConnectionState;
    protected abstract _reconnectInterrupter?: () => void;
    protected abstract _url?: string;
    protected _retryConfig: RetryConfiguration;
    protected _reconnectCount: number;
    protected _forceCloseTimeout: number;
    protected _onlineReconnectListener?: Promise<void>;
    protected _closeEstablishingTransmitter?: (() => void) | undefined;
    protected _store?: SDKStore;
    protected _joinChannelServiceRecordIndex?: number;
    protected abstract _transmitter?: T;
    protected _useCompress: boolean;
    protected _inflateLength: number;
    protected _deflateLength: number;
    constructor(name: string, _retryConfig: RetryConfiguration, useCompress: boolean, store?: SDKStore);
    protected resetReconnectCount(reason: "retry" | "tryNext" | "recover" | string): void;
    abstract getConnection(): any;
    abstract init(addresses: ServerAddress[], forceCloseTimeout: number): Promise<void>;
    close(failed?: boolean, lazyClose?: boolean): void;
    reconnect(reconnectMode?: "tryNext" | "retry" | "recover", reason?: TransmitterQuitReason): void;
    abstract sendMessage(...args: unknown[]): void;
    getInflateData(): {
        inflateLength: number;
        deflateLength: number;
    };
    protected setInflateData(data: TransmissionCompressedInfo): void;
    protected clearInflateData(): void;
    protected abstract createTransmitterConnection(address: unknown, isRetry?: boolean): Promise<void>;
    protected abstract reconnectWithAction(action: "tryNext" | "retry" | "recover" | string, needWaitTime: boolean): Promise<boolean>;
}

declare enum TransmitterQuitReason {
    NETWORK_ERROR = "NETWORK_ERROR",
    SERVER_ERROR = "SERVER_ERROR",
    MULTI_IP = "MULTI_IP",
    TIMEOUT = "TIMEOUT",
    OFFLINE = "OFFLINE",
    LEAVE = "LEAVE",
    P2P_FAILED = "P2P_FAILED",
    FALLBACK = "FALLBACK"
}
type TransmitterConnectionState = "connected" | "connecting" | "reconnecting" | "closed" | "failed";
interface TransmissionCompressedInfo {
    origin: AnyObject;
    originLength: number;
    shortKeyAndValue: AnyObject;
    msgpackSer: Uint8Array;
    compressed: Uint8Array;
    compressedLength: number;
    time: number;
}
interface TransmissonInfo {
    transmitter: Transmission;
    close: () => void;
}

declare abstract class P2PConnectionBaseImpl extends EventEmitter {
    onICEConnectionStateChange?: (ICEConnectionState: RTCIceConnectionState) => void;
    onConnectionStateChange?: (connectionState: RTCPeerConnectionState) => void;
    onDTLSTransportStateChange?: (state: RTCDtlsTransportState) => void;
    onDTLSTransportError?: (error: any) => void;
    onICETransportStateChange?: (state: RTCIceTransportState) => void;
    onFirstAudioReceived?: (ssrcId: number) => void;
    onFirstVideoReceived?: (ssrcId: number) => void;
    onFirstAudioDecoded?: (ssrcId: number) => void;
    onFirstVideoDecoded?: (ssrcId: number, width: number, height: number) => void;
    onFirstVideoRender?: (ssrcId: number) => void;
    onFirstVideoBufferReady?: (ssrcId: number) => void;
    onFirstVideoDecodedTimeout?: (ssrcId: number) => void;
    onSelectedLocalCandidateChanged?: (cur: CandidateStats, prev: CandidateStats) => void;
    onSelectedRemoteCandidateChanged?: (cur: CandidateStats, prev: CandidateStats) => void;
    onICECandidateError?: (errMsg: string) => void;
    getLocalVideoStats?: () => LocalVideoTrackStats & AgoraRTCStats;
    constructor(spec: PeerConnectionSpec, store: SDKStore);
    abstract get currentLocalDescription(): RTCSessionDescription | null;
    abstract get currentRemoteDescription(): RTCSessionDescription | null;
    abstract get peerConnectionState(): RTCPeerConnectionState;
    abstract get iceConnectionState(): RTCIceConnectionState;
    abstract get localCodecs(): SDK_CODEC[];
}
declare abstract class P2PConnectionImpl extends P2PConnectionBaseImpl {
    abstract establishPromise: Promise<EstablishParams>;
    constructor(spec: PeerConnectionSpec, store: SDKStore);
    abstract establish(): Promise<EstablishParams>;
    abstract connect(connectParams: ConnectionParams): Promise<void | TransmissonInfo>;
    abstract updateRemoteConnect(connectParams: ConnectionParams): Promise<void>;
    abstract updateRemoteRTPCapabilities(mids: string[], codecs: SDK_CODEC[]): Promise<void>;
    abstract getPreMedia(ssrcId: number): {
        mid: string;
        track: MediaStreamTrack;
        transceiver: RTCRtpTransceiver;
        player: AgoraRTCPlayer | undefined;
    } | undefined;
    abstract send(tracks: LocalTrack[], codec: SDK_CODEC, audioCodec: SDK_AUDIO_CODEC): AsyncGenerator<SSRCMessage[], {
        localSSRC: SSRCMessage;
        id: string;
    }[], (RemoteConfig | undefined)[]>;
    abstract stopSending(mids: string[]): Promise<void>;
    abstract receive(kind: Kind, ssrcMsg: SSRCMessage, mslabel: string, remoteConfig: RemoteConfig | undefined): Promise<{
        track: MediaStreamTrack;
        id: string;
        transceiver?: RTCRtpTransceiver;
    }>;
    abstract batchReceive(list: {
        kind: Kind;
        ssrcMsg: SSRCMessage;
        mslabel: string;
    }[]): Promise<{
        track: MediaStreamTrack;
        id: string;
        transceiver?: RTCRtpTransceiver;
    }[]>;
    abstract stopReceiving(mids: string[]): Promise<void>;
    abstract muteRemote(mid: string): Promise<void>;
    abstract unmuteRemote(mid: string): Promise<void>;
    abstract muteLocal(mids: string[]): Promise<void>;
    abstract unmuteLocal(ids: string[]): Promise<void>;
    abstract restartICE(type?: ICERestartType): AsyncGenerator<ICEParameters, void, {
        remoteIceParameters: ICEParameters;
    }>;
    abstract close(): void;
    abstract getStats(): AgoraPCStats;
    abstract getRemoteVideoIsReady(ssrcId: number): boolean;
    abstract updateEncoderConfig(mid: string, track: LocalTrack): Promise<void>;
    abstract updateSendParameters(mid: string, track: LocalTrack): Promise<void>;
    abstract setStatsRemoteVideoIsReady(ssrcId: number, isReady: boolean): void;
    abstract replaceTrack(track: LocalTrack, id: string): Promise<void>;
    abstract getRemoteSSRC(mid: string): Promise<number | undefined>;
    abstract createDataChannels(uid: UID, dataChannels: LocalDataChannel[] | RemoteDataChannel[]): Promise<void>;
    abstract stopDataChannels(uid: UID): Promise<void>;
    abstract setConfiguration(spec: PeerConnectionSpec): void;
}
interface RTPCapabilities {
    audioCodecs: PayloadAttribute[];
    videoCodecs: PayloadAttribute[];
    audioExtensions: Extmap[];
    videoExtensions: Extmap[];
}
interface ICEParameters {
    iceUfrag: string;
    icePwd: string;
}
interface DtlsParameters {
    fingerprints: FingerPrint[];
}
declare enum Kind {
    VIDEO = "video",
    AUDIO = "audio"
}
declare enum ICERestartType {
    UDP_RELAY = "udp_relay",
    UDP_TCP_RELAY = "udp_tcp_relay",
    TCP_RELAY = "tcp_relay",
    RELAY = "relay"
}
type EstablishParams = {
    iceParameters: ICEParameters;
    dtlsParameters: DtlsParameters;
    rtpCapabilities: RTPCapabilitiesBeforeMerge;
    offerSDP?: string;
};
type ConnectionParams = {
    iceParameters: ICEParameters;
    dtlsParameters: DtlsParameters;
    candidates: Candidate[];
    rtpCapabilities: RTPCapabilitiesWithDirection;
    setup: Setup;
    cname: string;
    preallocation?: boolean;
    preSSRCs?: PreSSRCMessage[];
};
type SSRCMessage = {
    ssrcId: number;
    rtx?: number;
}[];
type PreSSRCMessage = {
    kind: Kind;
    ssrcMsg: SSRCMessage;
    mslabel: string;
};
interface RTPCapabilitiesWithDirection {
    send: RTPCapabilities;
    recv: RTPCapabilities;
}
interface RTPCapabilitiesBeforeMerge extends Partial<RTPCapabilitiesWithDirection> {
    sendrecv?: RTPCapabilities;
}

declare class DataChannelConnection extends P2PConnectionImpl {
    name: string;
    private readonly store;
    private readonly peerConnection;
    private cname?;
    protected mutex: PromiseMutex;
    dataChannel: RTCDataChannel;
    get currentLocalDescription(): RTCSessionDescription | null;
    get currentRemoteDescription(): RTCSessionDescription | null;
    get peerConnectionState(): RTCPeerConnectionState;
    get iceConnectionState(): RTCIceConnectionState;
    get localCodecs(): SDK_CODEC[];
    private _p2pConnection;
    establishPromise: Promise<EstablishParams>;
    private _nvMedia?;
    constructor(spec: any, store: SDKStore);
    getPreMedia(ssrcId: number): {
        mid: string;
        track: MediaStreamTrack;
        transceiver: RTCRtpTransceiver;
        player: AgoraRTCPlayer | undefined;
        firstVideoRender?: number;
    } | undefined;
    isPreSub(): boolean;
    establish(): Promise<EstablishParams>;
    getP2PConnectionParams(): Promise<EstablishParams>;
    updateRtpSenderEncodings(track: LocalVideoTrack): Promise<void>;
    connect(connectParams: ConnectionParams): Promise<TransmissonInfo>;
    updateRemoteRTPCapabilities(mids: string[], codecs: SDK_CODEC[]): Promise<void>;
    send(tracks: LocalTrack[], codec: SDK_CODEC, audioCodec: SDK_AUDIO_CODEC): AsyncGenerator<SSRCMessage[], {
        localSSRC: SSRCMessage;
        id: string;
    }[], (RemoteConfig | undefined)[]>;
    stopSending(mids: string[], nolock?: boolean): Promise<void>;
    createDataChannels(uid: UID, dataChannels: LocalDataChannel[] | RemoteDataChannel[]): Promise<void>;
    stopDataChannels(uid: UID): Promise<void>;
    receive(kind: Kind, ssrcMsg: SSRCMessage, mslabel: string, remoteConfig?: RemoteConfig): Promise<{
        track: MediaStreamTrack;
        id: string;
        transceiver?: RTCRtpTransceiver;
    }>;
    batchReceive(receiveList: {
        kind: Kind;
        ssrcMsg: SSRCMessage;
        mslabel: string;
    }[]): Promise<{
        track: MediaStreamTrack;
        id: string;
    }[]>;
    stopReceiving(mids: string[]): Promise<void>;
    muteRemote(mid: string): Promise<void>;
    unmuteRemote(mid: string): Promise<void>;
    muteLocal(mids: string[]): Promise<void>;
    unmuteLocal(ids: string[]): Promise<void>;
    restartICE(type?: ICERestartType): AsyncGenerator<ICEParameters, void, {
        remoteIceParameters: ICEParameters;
    }>;
    close(): void;
    getStats(): AgoraPCStats;
    getRemoteVideoIsReady(ssrcId: number): boolean;
    updateRemoteConnect(connectParams: ConnectionParams): Promise<void>;
    updateEncoderConfig(mid: string, track: LocalTrack): Promise<void>;
    updateSendParameters(mid: string, track: LocalTrack): Promise<void>;
    setStatsRemoteVideoIsReady(ssrcId: number, isReady: boolean): void;
    replaceTrack(track: LocalTrack, mid: string): Promise<void>;
    getRemoteSSRC(mid: string): Promise<number | undefined>;
    private logSDPExchange;
    private static resolvePCConfiguration;
    private static turnServerConfigToIceServers;
    private bindPCEvents;
    private closeSignal;
    private unbindConnectionEvents;
    setConfiguration(spec: PeerConnectionSpec): void;
}

type StatsCounter = StatsCounter6s | StatsCounter3s | StatsCounter1s | StatsCounter60s;
declare enum StatsCounter60s {
    Video_Send_Type = 190
}
declare enum StatsCounter6s {
    Video_Send_Qp_Sum = 2143,
    Video_Send_Freeze = 2082,
    Video_Recv_Qp_Sum = 2144,
    Video_Recv_Freeze = 2084,
    Video_Render_Freeze_Time = 2109,
    Video_Render_Freeze_Time_Render = 2147,
    Video_Render_Freeze_Time_Render2 = 2223,
    Audio_Recv_Freeze = 2083
}
declare enum StatsCounter3s {
    Video_Send_Retransmit = 2062,
    Video_Send_Target_Encoded = 2064,
    Video_Send_Actual_Encoded = 2060,
    Video_Send_Transmit = 2066,
    Video_Send_Bandwidth = 2061,
    Video_Capture_Height = 2033,
    Video_Capture_Width = 2035,
    Video_Capture_Frame_Rate = 2034,
    Video_Send_Low_Height = 2073,
    Video_Send_Low_Frame_Rate = 2075,
    Video_Send_Low_Width = 2077,
    Video_Send_Low_Bitrate = 2069,
    Video_Send_Low_Package_Lost = 2070,
    Video_Send_Low_Package_Rate = 2071,
    Video_Send_Frame_Rate = 2002,
    Video_Send_Width = 2003,
    Video_Send_Height = 2004,
    Video_Send_Disabled = 2095,
    Video_Send_Adaptation = 2032,
    Video_Send_Player_Status = 2128,
    Video_Send_Nacks = 2009,
    Video_Send_Plis = 2010,
    Video_Send_Firs = 2011,
    Video_Send_Avg_Encode = 2007,
    Video_Send_Huge_Frame_Sent = 2174,
    Video_Send_Bytes_Retransmit = 2173,
    Video_Send_Packages_Retransmit = 2172,
    Video_Send_Key_Frames_Encoded = 2207,
    Video_Send_Bitrate = 2012,
    Video_Send_Package_Rate = 2031,
    Video_Send_Package_Lost = 2005,
    Audio_Capture_PCM_Level = 2104,
    Audio_Send_Level = 2038,
    Audio_Send_Bitrate = 2039,
    Audio_Send_Package_Rate = 2040,
    Audio_Send_AEC_Return_Loss = 2041,
    Audio_Send_AEC_Return_Loss_Enhancement = 2042,
    Audio_Send_Freeze = 2081,
    Audio_Send_Disabled = 2096,
    Audio_Send_Bytes_Retransmit = 2179,
    Audio_Send_Packages_Retransmit = 2180,
    Video_Recv_Height = 2019,
    Video_Recv_Width = 2018,
    Video_Recv_Frame_Rate_Output = 2155,
    Video_Recv_Jitter_Buffer = 2023,
    Video_Recv_Current_Delay = 2024,
    Video_Recv_Nacks = 2026,
    Video_Recv_Plis = 2027,
    Video_Recv_Firs = 2028,
    Video_Recv_Disabled = 2101,
    Video_Recv_Player_Status = 2129,
    Video_Recv_I_Frame_Delay = 2149,
    Video_Render_Frame_Rate_Render = 2022,
    Video_Render_Freeze_Duration = 2156,
    Audio_Render_Level = 2043,
    Audio_Render_Freeze_Time_80ms = 2226,
    Audio_Render_Freeze_Time_200ms = 2227,
    Audio_Render_Freeze_Samples_80ms = 2228,
    Audio_Render_Freeze_Samples_200ms = 2229,
    Audio_Recv_PCM_Level = 2105,
    Audio_Recv_Disabled = 2102,
    Audio_Recv_Jitter_Buffer = 2054,
    Audio_Recv_Current_Delay = 2047,
    Audio_Recv_Player_Status = 2130,
    Audio_Recv_Bitrate = 2044,
    Audio_Recv_Concealed_Samples = 2148,
    Audio_Recv_Total_Samples_Received = 2224
}
declare enum StatsCounter1s {
    Video_Render_Frame_Rate_Decode = 2021,
    Video_Recv_Frame_Rate = 2020,
    Video_Recv_Frame_Dropped = 2181,
    Video_Recv_Bytes_Retransmit = 2175,
    Video_Recv_Packages_Retransmit = 2176,
    Video_Recv_Packages_Discarded = 2198,
    Video_Recv_Avg_Decode = 2200,
    Video_Recv_Avg_Processing_Delay = 2202,
    Video_Recv_Avg_Assembly_Time = 2203,
    Video_Recv_Avg_Inter_Frame_Delay = 2204,
    Video_Recv_Key_Frames_Decoded = 2206,
    Video_Recv_Package_Lost = 2014,
    Video_Recv_Bitrate = 2029,
    Video_Recv_Package_Rate = 2078,
    Audio_Recv_Jitter = 2055,
    Audio_Recv_Bytes_Retransmit = 2178,
    Audio_Recv_Packages_Retransmit = 2177,
    Audio_Recv_Packages_Discarded = 2199,
    Audio_Recv_Avg_Processing_Delay = 2201,
    Audio_Recv_Package_Rate = 2046,
    Audio_Recv_Package_Lost = 2045,
    Audio_Recv_AV_Sync_TIME = 2237
}
interface UploadOutboundStats {
    high?: Partial<Record<StatsCounter, number>>;
    low?: Partial<Record<StatsCounter, number>>;
    audio?: Partial<Record<StatsCounter, number>>;
}
interface UploadInboundStats {
    peer: UID;
    video?: Partial<Record<StatsCounter, number>>;
    audio?: Partial<Record<StatsCounter, number>>;
}
declare enum TransportStatsCounter {
    RTT = 2006,
    CONN_TYPE = 801,
    STATS_UPDATE_INTERVAL = 2205
}
declare enum BaseTransportCounter {
    RTC_PEER_CONNECTION_STATE = 2219,
    PAGE_VISIBILITY = 2233
}
declare enum TransportBandwidthCounter {
    Transport_Send_Bitrate = 2234,
    Transport_Recv_Bitrate = 2235
}
interface UploadMixedStats {
    peer?: UID;
    video?: Record<StatsCounter, number>;
    audio?: Record<StatsCounter, number>;
    addition?: (Record<TransportStatsCounter, number | undefined> & Partial<Record<BaseTransportCounter | TransportBandwidthCounter, number>>) | Partial<Record<BaseTransportCounter, number>>;
}
interface UploadStatsInfo {
    inbound?: UploadInboundStats[];
    outbound?: UploadOutboundStats[];
    misc?: UploadMixedStats[];
}

declare enum PacketType {
    Default = 0,
    Ack = 1
}
interface MessagePacket {
    version: number;
    type: PacketType.Default;
    packetNumber: number;
    sendTs: number;
    payload: string | Uint8Array;
}
interface AckPacket {
    version: number;
    type: PacketType.Ack;
    maxAckPacketNumber: number;
    shift: number;
    ackSendTs: number;
}
declare class Transmitter {
    private version;
    private readonly initialRTO;
    private readonly maxBatchAckCount;
    private readonly maxRTO;
    private readonly initialRTT;
    private readonly ID;
    private rtt;
    private packetNumber;
    private rtoRatioMap;
    private timeoutMap;
    private unorderedPacketQueue;
    private batchAckPacketQueue;
    private lastOrderedPacketNumber;
    private batchAckTimer?;
    private readonly sendImpl;
    private readonly receiveImpl;
    constructor(sendImpl: (buffer: ArrayBuffer) => void, receiveImpl: (payload: string | ArrayBuffer) => void, options?: {
        initialRTO?: number;
        initialRTT?: number;
        maxBatchAckCount?: number;
        maxRTO?: number;
    });
    packetize(payload: string | Uint8Array, packetNumber: number): Omit<MessagePacket, "sendTs">;
    serialize(packet: MessagePacket | AckPacket): ArrayBuffer;
    deserialize(buffer: ArrayBuffer): MessagePacket | AckPacket;
    sendMessage(payload: string | Uint8Array): void;
    onData(data: ArrayBuffer): void;
    close(): void;
    private resendMessage;
    private calculateRTO;
    private updateRTT;
    private ack;
    private batchAck;
    private sendPacket;
    private clearRTO;
}

declare class AgoraDatachannelManager extends AgoraTransmissionMediumManager<RTCDataChannel> {
    protected _initMutex: PromiseMutex;
    protected _reconnectInterrupter?: (() => void) | undefined;
    protected _url?: string;
    protected _transmitter?: RTCDataChannel;
    private _addresses?;
    private _reliableTransmission?;
    private _textEncoder;
    private _textDecoder;
    constructor(name: string, _retryConfig: RetryConfiguration, useCompress?: boolean, store?: SDKStore);
    getConnection(): Transmitter | undefined;
    init(addresses: ServerAddress[], forceCloseTimeout?: number): Promise<void>;
    sendMessage(message: any, immediately?: boolean, isUint8ArrayMessage?: boolean): Promise<void>;
    unbindDcCloseEventListener(): void;
    private sendMessageWithJSON;
    private sendMessageWithUint8Array;
    protected createTransmitterConnection(address: ServerAddress): Promise<void>;
    protected reconnectWithAction(action: "retry" | "tryNext" | "recover", needWaitTime?: boolean): Promise<boolean>;
}

declare class DataChannelSignal extends EventEmitter {
    __name__: string;
    get connectionState(): SignalConnectionState;
    set connectionState(state: SignalConnectionState);
    get currentURLIndex(): number;
    private _disconnectedReason?;
    private _websocketReconnectReason?;
    private _connectionState;
    private reconnectToken?;
    get url(): string | null;
    get rtt(): number;
    websocket: AgoraDatachannelManager;
    openConnectionTime?: number;
    private clientId;
    private lastMsgTime;
    private uploadCache;
    private uploadCacheInterval?;
    private rttRolling;
    private pingpongTimer?;
    private inflateDataTimer?;
    private pingpongTimeoutCount;
    private ortc?;
    private joinResponse?;
    private multiIpOption?;
    private initError?;
    private spec;
    private store;
    private isJoining;
    private pendingNotifications;
    private processPendingNotifications;
    private handleUserBanned;
    constructor(spec: SignalSpec, store: SDKStore);
    request(type: SignalRequestType, payload?: any, noNeedToReSend?: boolean, noNeedResponse?: boolean): Promise<any>;
    waitMessage<T = any>(type: SignalNotifyType, filter?: (message: T) => boolean): Promise<T>;
    uploadWRTCStats(stats: UploadStatsInfo): void;
    upload(type: SignalUploadType, payload?: any): void;
    send(type: SignalRequestType, payload?: any): Promise<void>;
    init(urls: ServerAddress[]): Promise<any>;
    close(reason?: ConnectionDisconnectedReason): void;
    private join;
    private rejoin;
    reconnect(reconnectMode?: "retry" | "tryNext" | "recover", reason?: WebSocketQuitReason | TransmitterQuitReason): void;
    downgradeCodec(codec: string): Promise<boolean>;
    private handleNotification;
    private handlePingPong;
    private handleInflateData;
    private handleWebsocketEvents;
    private onWebsocketMessage;
}

type TRteServiceName = "ChannelMediaRelay" | "LiveStreaming" | "ImageModeration" | "ContentInspect" | "DataStream" | "P2PChannel" | "PlanBConnection" | "InterceptFrame" | "DataChannelConnection" | "DataChannelSignal";
interface IRteService<T = any, R = any> {
    name: TRteServiceName;
    create: (...args: any[]) => T;
    createSubmodule?: (...args: any[]) => R;
}

interface IDataChannelConnectionOptions {
    spec: PeerConnectionSpec;
    store: SDKStore;
}
interface IDataChannelSignalOptions {
    spec: SignalSpec;
    store: SDKStore;
}

declare const DataChannelConnectionService: IRteService<DataChannelConnection>;
declare const DataChannelSignalService: IRteService<DataChannelSignal>;

export { DataChannelConnectionService, DataChannelSignalService };
export type { IDataChannelConnectionOptions, IDataChannelSignalOptions };
